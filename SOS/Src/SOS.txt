- Lexical closures
- Non-constant upvalues
- Co-routines
- Iteration
- Number of elements in table
- Compiled fragment saving / loading
- Compiled code optimizer

- String concatenation operator
- String length/element access operations
- nil value
- For loops
- Tail function calls

- Garbage collection
- Script to native code calls
- Native code to script calls
- Grammar optimizer

- Automatic function execution parallelism


+ Non-stack based instruction set
+ Multiple return value rules for expressions
+ Real local variables / scoping

-------------------------------------------------------------------------------

Constant ::= "true" | "false" | String | Number | Table
Variable ::= Identifier
Call ::= ( Variable | FunctionDef ) "(" [ ExpressionList ] ")" { "(" [ ExpressionList ] ")" }
Indexable ::= Call | Variable | "(" Expression ")" 
Index ::= "[" Expression "]"
Operand ::= Constant | ( Indexable { Index } )
Power ::= Operand [ "^" Power ]
Mult ::= Power { ( "*" | "/" ) Power }
Sum ::= ["+" | "-"] Mult { ( "+" | "-" ) Mult }

Comparison ::= Sum [ ("==" | "~=" | "<" | ">" | "<=" | ">=") Sum ]
Not ::= [ "not" ] Comparison
And ::= Not { "and" Not }
Or ::= And { "or" And }

TableKey = Identifier | Constant
TableValue = [ TableKey "=" ] Expression
Table ::= "{" [ TableValue { "," TableValue } [ "," ] ] "}"

IdentifierList ::= Identifier { "," Identifier }
FunctionDef ::= "function" "(" [ IdentifierList ] ")" { Operator } "end"
Expression ::= Or | FunctionDef
ExpressionList ::= Expression { "," Expression }

Locals ::= "local" IdentifierList [ "=" ExpressionList ]
LValue ::= ( Indexable Index { Index } ) | Variable
Assignment ::= LValue { "," LValue } "=" ExpressionList

Return ::= "return" [ ExpressionList ]
If ::= "if" Expression "then" { Operator } [ "else" { Operator } ] "end"
While ::= "while" Expression "do" { Operator } "end"

Operator ::= While | If | Return | Locals | Assignment | Call
