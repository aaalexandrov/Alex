#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, std140) uniform Data {
    mat4 view_proj;
    vec4 pix_value;
    uint num_tri_indices;
    uint num_vertices;
    uint num_bvh_nodes;
};

layout(set = 0, binding = 1, rgba8) uniform image2D Output;

layout(set = 0, binding = 2, std430) buffer Vertices {
    float vert[];
};

layout(set = 0, binding = 3, std430) buffer TriIndices {
    uint tri_indices[];
};

struct BvhNode {
    vec3 box_min; 
    uint tri_start;
    vec3 box_max;
    uint tri_end;
    uint child[2];
    uint _pad[2];
};

layout(set = 0, binding = 4, std430) buffer BvhNodes {
    BvhNode bvh_nodes[];
};

const float inf = 1.0 / 0.0;

struct Ray {
    vec3 o;
    vec3 d;
};

struct Box {
    vec3 min;
    vec3 max;
};

vec2 intersect_box(Box box, Ray r) {
    float t0 = -inf, t1 = inf;
    for (uint dim = 0; dim < 3; ++dim) {
        float d = r.d[dim];
        float o = r.o[dim];
        float bmin = box.min[dim];
        float bmax = box.max[dim];
        if (abs(d) < 1e-5) {
            if (o < bmin || bmax < o)
                return vec2(1, -1);
            continue;
        }

        float x0 = (bmin - o) / d;
        float x1 = (bmax - o) / d;
        t0 = max(t0, d > 0 ? x0 : x1);
        t1 = min(t1, d > 0 ? x1 : x0);
        if (t0 > t1)
            break;
    }
    return vec2(t0, t1);
}

Box box_from_tri(vec3 tri[3]) {
    Box box;
    box.min = box.max = tri[0];
    for (int i = 1; i < 3; ++i) {
        box.min = min(box.min, tri[i]);
        box.max = max(box.max, tri[i]);
    }
    return box;
}

vec3 bary(vec3 v0, vec3 v1, vec3 v2, vec3 p) {
    vec3 e1 = v1 - v0;
    vec3 e2 = v2 - v0;
    vec3 p0 = p - v0;

    float e1proje2 = dot(e1, e2) / dot(e2, e2); 
    vec3 e1o = e1 - e1proje2 * e2;

    float t1o = dot(p0, e1o) / dot(e1o, e1o);
    float t2 = dot(p0, e2) / dot(e2, e2);

    float c1 = t1o;
    float c2 = t2 - t1o*e1proje2;

    vec3 bc = vec3(1 - c1 - c2, c1, c2);
    return bc;
}

vec4 intersect(vec3 v0, vec3 v1, vec3 v2, Ray r) {
    // vec3 tri[3] = {v0, v1, v2};
    // Box box = box_from_tri(tri);
    // vec2 ray_int = intersect_box(box, r);
    // if (ray_int[0] > ray_int[1])
    //     return vec4(-2);

    vec3 e1 = v1 - v0;
    vec3 e2 = v2 - v0;
    vec3 n = cross(e1, e2);
    float nd = dot(n, r.d);
    if (nd < 1e-5)
        return vec4(-1);
    float t = dot(n, v0 - r.o) / nd;

    vec3 p = r.o+t*r.d;
    vec3 bc = bary(v0, v1, v2, p);

    return vec4(bc, t);
}

vec4 intersect_tri(uint tri_index_index, Ray r) {
    uint i = tri_index_index;
    vec3 v0 = vec3(
        vert[tri_indices[i + 0] * 3 + 0],
        vert[tri_indices[i + 0] * 3 + 1],
        vert[tri_indices[i + 0] * 3 + 2]);

    vec3 v1 = vec3(
        vert[tri_indices[i + 1] * 3 + 0],
        vert[tri_indices[i + 1] * 3 + 1],
        vert[tri_indices[i + 1] * 3 + 2]);

    vec3 v2 = vec3(
        vert[tri_indices[i + 2] * 3 + 0],
        vert[tri_indices[i + 2] * 3 + 1],
        vert[tri_indices[i + 2] * 3 + 2]);

    vec4 bc_tri = intersect(v0, v1, v2, r);
    return bc_tri;    
}

void main() {
    ivec2 pixCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 outputSize = imageSize(Output);

    vec2 pix = vec2(pixCoord) / outputSize * 2 - 1;

    vec4 o = view_proj * vec4(pix, 0, 1);
    vec4 p = view_proj * vec4(pix, 0.5, 1);
    o /= o.w;
    p /= p.w;

    Ray r;
    r.o = o.xyz;
    r.d = normalize((p - o).xyz);

    vec4 bc = vec4(-1, -1, -1, inf);
    
    uint num_node_indices = 1;
    uint node_indices[32];
    node_indices[0] = 0;

    uint visited_nodes = 0;
    uint rejected_tri_boxes = 0;


    while (num_node_indices > 0) {
        ++visited_nodes;

        uint b = node_indices[--num_node_indices];

        BvhNode node = bvh_nodes[b];
        Box box;
        box.min = node.box_min;
        box.max = node.box_max;
        vec2 ray_int = intersect_box(box, r);
        if (ray_int[0] > ray_int[1])
            continue;

        for (uint t = node.tri_start; t < node.tri_end; ++t) {
            vec4 bc_tri = intersect_tri(t * 3, r);
            if (bc_tri == vec4(-2))
                ++rejected_tri_boxes;
            if (all(greaterThanEqual(bc_tri, vec4(0.0))) && bc_tri.w < bc.w) {
                bc = bc_tri;
            }
        }

        for (uint c = 0; c < 2; ++c) {
            if (node.child[c] > num_bvh_nodes)
                continue;
            node_indices[num_node_indices++] = node.child[c];
        }
    }

    float w = float(all(greaterThanEqual(bc, vec4(0.0))));

    imageStore(Output, pixCoord, vec4(w*bc.xyz, pix_value.a));
    //imageStore(Output, pixCoord, vec4(vec3(visited_nodes / float(num_bvh_nodes)), pix_value.a));
    //imageStore(Output, pixCoord, vec4(vec3(rejected_tri_boxes / float(num_tri_indices / 3)), pix_value.a));
    //imageStore(Output, pixCoord, vec4(vec3(rejected_tri_boxes / float(1000)), pix_value.a));
}
